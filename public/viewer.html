<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>QuestMirror â€” Receiver</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:     #07080f;
      --bg2:    #0d0f1a;
      --bg3:    #131625;
      --border: #1e2238;
      --accent: #5b6ef5;
      --accent2:#7c8fff;
      --green:  #2dff8f;
      --red:    #ff4466;
      --yellow: #ffcc44;
      --text:   #e8eaf6;
      --text2:  #7a82aa;
      --text3:  #3d4266;
      --mono:   'Space Mono', monospace;
      --sans:   'Syne', sans-serif;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; background: #000; overflow: hidden; }

    /* â”€â”€ SETUP OVERLAY â”€â”€ */
    #setup-overlay {
      position: fixed; inset: 0; z-index: 100;
      background: var(--bg);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 20px; padding: 24px;
      font-family: var(--sans);
    }
    .logo { font-size: 1.3rem; font-weight: 800; letter-spacing: -0.5px; color: var(--text); }
    .logo span { color: var(--accent2); }
    .logo small { display: block; font-size: 0.7rem; font-family: var(--mono); color: var(--text2); letter-spacing: 3px; text-transform: uppercase; margin-top: 2px; text-align: center; }

    .card {
      background: var(--bg2); border: 1px solid var(--border);
      border-radius: 18px; padding: 28px;
      width: 100%; max-width: 400px;
      display: flex; flex-direction: column; gap: 16px;
    }
    .field label {
      display: block; font-size: 0.7rem; font-family: var(--mono);
      color: var(--text2); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 8px;
    }
    .field input {
      width: 100%; background: var(--bg3); border: 1px solid var(--border);
      border-radius: 10px; padding: 14px; color: var(--accent2);
      font-family: var(--mono); font-size: 2rem; font-weight: 700;
      letter-spacing: 10px; text-align: center; outline: none;
      transition: border-color 0.2s;
    }
    .field input:focus { border-color: var(--accent); }
    .field input::placeholder { color: var(--text3); font-size: 1.4rem; letter-spacing: 6px; }

    .btn {
      width: 100%; background: var(--accent); color: #fff; border: none;
      border-radius: 10px; padding: 13px; font-family: var(--sans);
      font-size: 1rem; font-weight: 700; cursor: pointer; transition: all 0.2s;
    }
    .btn:hover { background: var(--accent2); transform: translateY(-1px); }
    .btn:disabled { background: var(--bg3); color: var(--text3); cursor: default; transform: none; }
    .btn.secondary {
      background: var(--bg3); color: var(--text2);
      border: 1px solid var(--border); margin-top: -8px;
    }
    .btn.secondary:hover { color: var(--text); border-color: var(--border); background: var(--bg3); transform: none; }

    .error-msg {
      font-family: var(--mono); font-size: 0.78rem; color: var(--red);
      background: rgba(255,68,102,0.08); border: 1px solid rgba(255,68,102,0.2);
      border-radius: 8px; padding: 10px; text-align: center; display: none;
    }

    /* â”€â”€ WAITING â”€â”€ */
    #waiting-screen {
      position: fixed; inset: 0; z-index: 50;
      background: var(--bg);
      display: none; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 16px; font-family: var(--sans); color: var(--text);
    }
    .spinner {
      width: 44px; height: 44px;
      border: 3px solid var(--border); border-top-color: var(--accent);
      border-radius: 50%; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #waiting-screen h2 { font-size: 1.2rem; font-weight: 800; }
    #waiting-screen p  { font-size: 0.82rem; color: var(--text2); font-family: var(--mono); }

    /* â”€â”€ PLAYER â”€â”€ */
    #player-screen {
      position: fixed; inset: 0; z-index: 10;
      background: #000; display: none;
    }
    #main-video {
      width: 100%; height: 100%;
      object-fit: contain; background: #000;
    }

    /* HUD */
    #hud {
      position: fixed; top: 0; left: 0; right: 0; z-index: 20;
      display: flex; align-items: center; justify-content: space-between;
      padding: 16px 20px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
      pointer-events: none;
      opacity: 0; transition: opacity 0.3s;
    }
    #hud.visible { opacity: 1; pointer-events: all; }
    .hud-label {
      display: flex; align-items: center; gap: 10px;
      font-family: var(--mono); font-size: 0.85rem; color: #fff;
    }
    .hud-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); box-shadow: 0 0 8px var(--green); animation: blink 1.5s infinite; }
    @keyframes blink { 0%,100%{opacity:1}50%{opacity:0.3} }
    .hud-server { font-size: 0.75rem; color: rgba(255,255,255,0.5); font-family: var(--mono); }

    .btn-exit-hud {
      background: rgba(255,255,255,0.1); backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.15); color: #fff;
      border-radius: 8px; padding: 6px 14px; cursor: pointer;
      font-family: var(--mono); font-size: 0.75rem; transition: all 0.2s;
    }
    .btn-exit-hud:hover { background: rgba(255,68,102,0.3); border-color: rgba(255,68,102,0.4); }

    /* Timer bar */
    #timer-bar-wrap {
      position: fixed; bottom: 0; left: 0; right: 0; height: 3px;
      background: rgba(255,255,255,0.08); z-index: 20;
    }
    #timer-bar {
      height: 100%; width: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
    }

    /* Sender dots */
    #sender-dots {
      position: fixed; bottom: 14px; right: 20px; z-index: 20;
      display: flex; gap: 8px; pointer-events: none;
    }
    .sdot {
      width: 8px; height: 8px; border-radius: 50%;
      background: rgba(255,255,255,0.2); transition: all 0.3s;
    }
    .sdot.active { background: var(--green); box-shadow: 0 0 8px var(--green); }

    /* Quest label bottom left */
    #quest-label {
      position: fixed; bottom: 14px; left: 20px; z-index: 20;
      font-family: var(--mono); font-size: 0.78rem; color: rgba(255,255,255,0.5);
      pointer-events: none;
    }

    /* Flash on switch */
    #flash {
      position: fixed; inset: 0; z-index: 30;
      background: #fff; opacity: 0; pointer-events: none;
      transition: opacity 0.15s;
    }
  </style>
</head>
<body>

<!-- â”€â”€ SETUP â”€â”€ -->
<div id="setup-overlay">
  <div class="logo">Quest<span>Mirror</span> <small>Receiver</small></div>
  <div class="card">
    <div class="field">
      <label>ID do Server (6 dÃ­gitos)</label>
      <input type="text" id="input-id" placeholder="000000" maxlength="6" inputmode="numeric" autofocus/>
    </div>
    <div class="error-msg" id="setup-error">Server nÃ£o encontrado.</div>
    <button class="btn" id="connect-btn">Conectar</button>
  </div>
</div>

<!-- â”€â”€ WAITING â”€â”€ -->
<div id="waiting-screen">
  <div class="spinner"></div>
  <h2>Aguardando senders...</h2>
  <p id="waiting-info">Conectado ao server. Esperando Quests.</p>
</div>

<!-- â”€â”€ PLAYER â”€â”€ -->
<div id="player-screen">
  <video id="main-video" autoplay playsinline></video>
</div>

<!-- HUD (toque na tela para mostrar) -->
<div id="hud">
  <div class="hud-label">
    <span class="hud-dot"></span>
    <span id="hud-quest">â€”</span>
  </div>
  <div class="hud-server" id="hud-server">â€”</div>
  <button class="btn-exit-hud" id="exit-btn">âœ• Sair</button>
</div>

<div id="timer-bar-wrap"><div id="timer-bar"></div></div>
<div id="sender-dots"></div>
<div id="quest-label" id="quest-label-bottom"></div>
<div id="flash"></div>

<script type="module">
  import { initializeApp }       from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getFirestore, collection, query, where,
           getDocs, doc, setDoc, onSnapshot,
           serverTimestamp, deleteDoc }
                                  from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  const firebaseConfig = {
    apiKey:            "AIzaSyCEPrlqbW7ec7mSJLJF6lrY6pk-F1EXGTE",
    authDomain:        "questmirror-server.firebaseapp.com",
    projectId:         "questmirror-server",
    storageBucket:     "questmirror-server.firebasestorage.app",
    messagingSenderId: "248196878452",
    appId:             "1:248196878452:web:2c92315ea5e2edca5a0121"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getFirestore(app);

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const SWITCH_INTERVAL = 10000;
  let serverDocId   = null;
  let serverData    = null;
  let receiverId    = 'recv_' + Math.random().toString(36).substring(2, 10);
  let senders       = [];       // [{ docId, questName, connected }]
  let currentIndex  = 0;
  let peerConns     = {};       // senderDocId â†’ RTCPeerConnection
  let remoteStreams  = {};       // senderDocId â†’ MediaStream
  let unsubSenders  = null;
  let switchTimer   = null;
  let timerAnimId   = null;
  let hudTimer      = null;
  let unsubSignals  = {};       // senderDocId â†’ unsubscribe fn

  const iceConfig = { iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' }
  ]};

  // â”€â”€ DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const setupOverlay  = document.getElementById('setup-overlay');
  const waitingScreen = document.getElementById('waiting-screen');
  const playerScreen  = document.getElementById('player-screen');
  const connectBtn    = document.getElementById('connect-btn');
  const inputId       = document.getElementById('input-id');
  const setupError    = document.getElementById('setup-error');
  const mainVideo     = document.getElementById('main-video');
  const hud           = document.getElementById('hud');
  const exitBtn       = document.getElementById('exit-btn');
  const timerBar      = document.getElementById('timer-bar');
  const senderDots    = document.getElementById('sender-dots');
  const questLabel    = document.getElementById('quest-label');
  const flashEl       = document.getElementById('flash');

  // Load saved ID
  const savedId = localStorage.getItem('qm-receiver-id');
  if (savedId) inputId.value = savedId;

  inputId.addEventListener('input', () => {
    inputId.value = inputId.value.replace(/\D/g, '').substring(0, 6);
  });

  // â”€â”€ CONNECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  connectBtn.addEventListener('click', async () => {
    const id = inputId.value.trim();
    if (id.length !== 6) { showError('O ID deve ter 6 dÃ­gitos'); return; }

    connectBtn.disabled = true;
    connectBtn.textContent = 'Conectando...';
    setupError.style.display = 'none';

    try {
      const q    = query(collection(db, 'servers'), where('serverId', '==', id));
      const snap = await getDocs(q);

      if (snap.empty) { showError('Server nÃ£o encontrado.'); reset(); return; }

      serverDocId = snap.docs[0].id;
      serverData  = snap.docs[0].data();

      if (!serverData.active) { showError('Server desativado.'); reset(); return; }

      localStorage.setItem('qm-receiver-id', id);

      // Go to waiting
      setupOverlay.style.display  = 'none';
      waitingScreen.style.display = 'flex';
      document.getElementById('waiting-info').textContent =
        'Conectado ao server "' + serverData.name + '". Esperando Quests.';
      document.getElementById('hud-server').textContent = serverData.name + ' Â· ' + id;

      // Listen for senders
      listenSenders();

    } catch(e) {
      showError('Erro: ' + e.message); reset();
    }
  });
  inputId.addEventListener('keydown', e => { if(e.key==='Enter') connectBtn.click(); });

  // â”€â”€ LISTEN SENDERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function listenSenders() {
    const ref = collection(db, 'servers', serverDocId, 'senders');
    unsubSenders = onSnapshot(ref, async (snap) => {
      senders = snap.docs
        .map(d => ({ docId: d.id, ...d.data() }))
        .filter(s => s.connected);

      updateDots();

      // Connect to any new sender not yet connected
      for (const sender of senders) {
        if (!peerConns[sender.docId]) {
          await requestStreamFromSender(sender);
        }
      }

      // Clean up disconnected senders
      for (const docId of Object.keys(peerConns)) {
        if (!senders.find(s => s.docId === docId)) {
          peerConns[docId].close();
          delete peerConns[docId];
          delete remoteStreams[docId];
          if (unsubSignals[docId]) { unsubSignals[docId](); delete unsubSignals[docId]; }
        }
      }

      if (senders.length > 0) {
        waitingScreen.style.display = 'none';
        playerScreen.style.display  = 'block';
        if (!switchTimer) startCycle();
        if (!isCurrentValid()) switchTo(0);
      } else {
        waitingScreen.style.display = 'flex';
        playerScreen.style.display  = 'none';
        stopCycle();
      }
    });
  }

  // â”€â”€ REQUEST STREAM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function requestStreamFromSender(sender) {
    // Signal sender that we want to connect
    const sigDoc = doc(db, 'servers', serverDocId, 'senders', sender.docId, 'signaling', receiverId);
    await setDoc(sigDoc, { type: 'request', receiverId, ts: serverTimestamp() });

    // Listen for offer from sender
    unsubSignals[sender.docId] = onSnapshot(sigDoc, async (snap) => {
      if (!snap.exists()) return;
      const data = snap.data();

      if (data.type === 'offer' && !peerConns[sender.docId]) {
        await handleOffer(sender, data.offer);
      }
      if (data.type === 'ice-sender' && peerConns[sender.docId]) {
        try {
          await peerConns[sender.docId].addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch(e) {}
      }
    });
  }

  async function handleOffer(sender, offer) {
    const pc = new RTCPeerConnection(iceConfig);
    peerConns[sender.docId] = pc;

    pc.ontrack = ({ streams }) => {
      remoteStreams[sender.docId] = streams[0];
      if (senders[currentIndex]?.docId === sender.docId) {
        showStream(sender.docId);
      }
    };

    pc.onicecandidate = async ({ candidate }) => {
      if (candidate) {
        const sigDoc = doc(db, 'servers', serverDocId, 'senders', sender.docId, 'signaling', receiverId);
        await setDoc(sigDoc, { type: 'ice-receiver', candidate: candidate.toJSON() }, { merge: true });
      }
    };

    pc.onconnectionstatechange = () => {
      if (['disconnected','failed','closed'].includes(pc.connectionState)) {
        delete peerConns[sender.docId];
        delete remoteStreams[sender.docId];
      }
    };

    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    const sigDoc = doc(db, 'servers', serverDocId, 'senders', sender.docId, 'signaling', receiverId);
    await setDoc(sigDoc, { type: 'answer', answer: { type: answer.type, sdp: answer.sdp } }, { merge: true });
  }

  // â”€â”€ DISPLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function showStream(senderDocId) {
    const stream = remoteStreams[senderDocId];
    if (!stream) return;
    mainVideo.srcObject = stream;
    const sender = senders.find(s => s.docId === senderDocId);
    const label  = sender ? 'ðŸ¥½ ' + sender.questName : 'ðŸ¥½ Quest';
    document.getElementById('hud-quest').textContent = label;
    questLabel.textContent = label;
  }

  function isCurrentValid() {
    return senders.length > 0 &&
           senders[currentIndex] &&
           remoteStreams[senders[currentIndex].docId];
  }

  function switchTo(index) {
    if (senders.length === 0) return;
    currentIndex = ((index % senders.length) + senders.length) % senders.length;
    const target = senders[currentIndex];
    flashTransition(() => showStream(target.docId));
    updateDots();
    restartTimerBar();
  }

  function flashTransition(cb) {
    flashEl.style.opacity = '0.12';
    setTimeout(() => { cb(); flashEl.style.opacity = '0'; }, 150);
  }

  // â”€â”€ CYCLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function startCycle() {
    stopCycle();
    const interval = (serverData?.rotationInterval || 10) * 1000;
    if (interval === 0) return; // manual mode
    switchTimer = setInterval(() => {
      if (senders.length > 1) switchTo(currentIndex + 1);
    }, interval);
    restartTimerBar();
  }

  function stopCycle() {
    if (switchTimer) { clearInterval(switchTimer); switchTimer = null; }
    if (timerAnimId) { cancelAnimationFrame(timerAnimId); timerAnimId = null; }
    timerBar.style.width = '100%';
  }

  function restartTimerBar() {
    if (timerAnimId) cancelAnimationFrame(timerAnimId);
    const interval = (serverData?.rotationInterval || 10) * 1000;
    if (interval === 0) { timerBar.style.width = '0'; return; }
    const start = performance.now();
    function frame(now) {
      const pct = Math.max(0, 100 - ((now - start) / interval) * 100);
      timerBar.style.width = pct + '%';
      if (pct > 0) timerAnimId = requestAnimationFrame(frame);
    }
    timerAnimId = requestAnimationFrame(frame);
  }

  // â”€â”€ DOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function updateDots() {
    senderDots.innerHTML = senders.map((s, i) =>
      `<div class="sdot ${i === currentIndex ? 'active' : ''}"></div>`
    ).join('');
  }

  // â”€â”€ HUD (show on tap/click) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.addEventListener('click', () => {
    hud.classList.add('visible');
    clearTimeout(hudTimer);
    hudTimer = setTimeout(() => hud.classList.remove('visible'), 3000);
  });

  exitBtn.addEventListener('click', () => {
    stopCycle();
    if (unsubSenders) unsubSenders();
    Object.values(unsubSignals).forEach(u => u());
    Object.values(peerConns).forEach(pc => pc.close());
    mainVideo.srcObject = null;
    playerScreen.style.display  = 'none';
    waitingScreen.style.display = 'none';
    setupOverlay.style.display  = 'flex';
    connectBtn.disabled = false;
    connectBtn.textContent = 'Conectar';
  });

  // â”€â”€ UTILS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function showError(msg) { setupError.textContent = msg; setupError.style.display = 'block'; }
  function reset() { connectBtn.disabled = false; connectBtn.textContent = 'Conectar'; }

  // Auto-connect if saved ID
  if (savedId && savedId.length === 6) {
    setTimeout(() => connectBtn.click(), 300);
  }
</script>
</body>
</html>